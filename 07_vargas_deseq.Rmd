---
title: "DESeq2 Analysis Report of Salmonella data"
author: "Pedro Miura"
date: "`r Sys.Date()`"
output: 
  html_document:
    self_contained: true
output_dir: "/cloud/project/results"
---


# Setup
```{r setupx, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
knitr::opts_knit$set(root.dir = "/cloud/project")
```

# Install
```{r install}
# List of required packages
required_packages1 <- c("dplyr", "ggplot2", "ggrepel", "rmarkdown", "knitr")

# Install only if not already installed
for (pkg in required_packages1) {
  if (!(pkg %in% installed.packages()[, "Package"])) {
    install.packages(pkg)
  }
}
```

# Install 2
```{r bioconducInstall}
# List of required packages
required_packages2 <- c("BiocManager", "DESeq2")

# Function to install packages if not already installed
install_if_needed <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (pkg == "BiocManager") {
      install.packages(pkg)
    } else {
      # Use BiocManager to install Bioconductor packages
      if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
      }
      BiocManager::install(pkg, update = FALSE, ask = FALSE) #this ensures installation is non-interactive, which is cruicial for knitting.
    }
  }
}

# Install all required packages
lapply(required_packages2, install_if_needed)

```


# Load Required Libraries
```{r load_libraries}
library("dplyr", quietly = TRUE, warn.conflicts = FALSE)
library("DESeq2", quietly = TRUE, warn.conflicts = FALSE)
library("ggplot2", quietly = TRUE, warn.conflicts = FALSE)
library("ggrepel", quietly = TRUE, warn.conflicts = FALSE)

```
# Description of our data

Here, we are analyzing a bacteria experiment that has three samples. 
Wild type (WT), Sample1 (TRPRS1 knockout), Sample2(TRPRS2 knockout)

The data is an RNA-Seq dataset- paired end, stranded, that was aligned to a reference genome using STAR, and read counts generated by HT-seq.

# Read and Process Count Matrix

```{r arrange}
counts <- read.delim("/cloud/project/data/deseq2_input.tsv", row.names = 1, check.names = FALSE)
head(counts)
columns_to_keep <- c("WT1", "WT2", "WT3", "TRPRS1.1", "TRPRS1.2", "TRPRS1.3", "TRPRS2.1", "TRPRS2.2", "TRPRS2.3")
counts <- round(counts %>% select(all_of(columns_to_keep)))
```

# Read Metadata
```{r meta}
metadata <- read.delim("/cloud/project/data/metadata.tsv", row.names = 1)
#inspect metadata. What do you see?
metadata$Condition <- as.factor(metadata$Condition)
```

# Create DESeq2 Object
```{r deseq}
dds <- DESeqDataSetFromMatrix(countData = counts, colData = metadata, design = ~ Condition)
dds$Condition <- relevel(dds$Condition, ref = "WT")
dds <- DESeq(dds)
```

# Create Function to add common name
```{r common}
add_common_name <- function(results_df, counts_names) {
  # Convert results_df to a data frame (if it's not already)
  results_df <- as.data.frame(results_df)
  
  # Add a gene_id column based on row names
  results_df$gene_id <- rownames(results_df)
  
  # Join with counts_names to add the common_name column
  results_df <- left_join(results_df, counts_names, by = c("gene_id" = "Gene"))
  
  # Return the updated results table
  return(results_df)
}
```

# Add common name
```{r commonz}
# get "common_name" to go with "Gene" name
getwd()
list.files("/cloud/project/data/")
counts_names <- read.delim("/cloud/project/data/counts_names.tsv", check.names = FALSE)
head(counts_names)
#inspect count_names
```

# Filter out genes with very low expression
```{r filterz}
# sum counts for each gene across samples
sumcounts <- rowSums(counts(dds))
# take the log
logsumcounts <- log(sumcounts,base=10)
# plot a histogram of the log scaled counts
hist(logsumcounts,breaks=100)

# get genes with summed counts greater than 50
keep <- sumcounts > 10

# keep only the genes for which the vector "keep" is TRUE
dds <- dds[keep,]

sumcounts <- rowSums(counts(dds))
logsumcounts <- log(sumcounts,base=10)
hist(logsumcounts,breaks=100)
```
# Perform Differential Expression Analysis
```{r DE1}
res1 <- results(dds, contrast = c("Condition", "TRPRS1", "WT"))
res1 <- res1[order(res1$padj), ]
nrow(res1)

res1 <- add_common_name(res1, counts_names)
res1 <- res1 %>%
  select(gene_id, common_name, everything())
nrow(res1)
write.table(res1, file = "/cloud/project/results/deseq2_results_TRPRS1.tsv", sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)


res2 <- results(dds, contrast = c("Condition", "TRPRS2", "WT"))
res2 <- res2[order(res2$padj), ]
res2 <- add_common_name(res2, counts_names)
res2 <- res2 %>%
  select(gene_id, common_name, everything())
write.table(res2, file = "/cloud/project/results/deseq2_results_TRPRS2.tsv", sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)

```

# PCA Plot
```{r PCA}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("Condition"))
rm (vsd)
gc()
```


# add common gene names 
```{r addcom}
#dds <- DESeq(dds)
#why do I need this again? I don't think so. 

#dds will be our results object
attr(dds,"modelMatrix")

resultsNames(dds)

# check individual gene

colnames(colData(dds))
# [1] "Condition"  "sizeFactor"


#
# import counts with common names
counts_names <- read.delim("/cloud/project/data/counts_names.tsv", check.names = FALSE)
# column common_name 

head (counts_names)
# Example: Look up the common name for a specific gene ID
gene_id <- "gene-STM14_RS23910"
common_name <- counts_names$common_name[counts_names$Gene == gene_id]

# Create a custom title
plot_title <- paste(gene_id, " (", common_name, ")", sep = "")

# Plot the counts with the custom title
plotCounts(dds, gene_id, intgroup = c("Condition"), main = plot_title)
```



#Make gene plot function

```{r function_single_gene_plots}

# Define the function
plot_gene_counts_list <- function(gene_ids, dds, counts_names, intgroup = c("Condition")) {
  # Loop through each gene ID in the list
  for (gene_id in gene_ids) {
    # Look up the common name for the given gene_id
    common_name <- counts_names$common_name[counts_names$Gene == gene_id]
    
    # Create a custom title
    plot_title <- paste(gene_id, " (", common_name, ")", sep = "")
    
    # Plot the counts with the custom title
    plotCounts(dds, gene_id, intgroup = intgroup, main = plot_title)
  }
}
```

# Verify knockout

These are the names for the genes that are knocked out:
 
TRPRS1 = STM14_RS18470
coordinates are NC_016856.1:3,648,142-3,653,146
 
TRPRS2 = STM14_RS23620
coordinates are NC_016856.1:4,772,659-4,777,672
 
The common name for both of these genes is "trpS". Often we need more than a common name (see ENSEMBL gene naming)

```{r knocx}
# Example usage to check the knockout genes.
gene_ids <- c("gene-STM14_RS18470", "gene-STM14_RS23620")
plot_gene_counts_list(gene_ids, dds, counts_names)
```


# Volcano Plots for TRPRS1
```{r morevolc}


ggplot(res1, aes(x = log2FoldChange, y = -log10(padj))) +  # Replace res2 with res1
  geom_point(aes(color = padj < 0.05 & abs(log2FoldChange) > 1), alpha = 0.7, na.rm = T) +  # Update the color condition
  scale_color_manual(values = c("black", "red")) +  # Black for non-significant, red for significant
  theme_minimal() +
  theme(legend.position = "none") +  # Remove the legend
  labs(
    title = "Volcano Plot: TRPRS1 vs WT",  # Update the title
    x = "Log2 Fold Change",
    y = "-Log10 Adjusted P-value"
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "blue") +  # P-value cutoff line
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "blue") +  # Fold change cutoff lines
  geom_text_repel(
    data = subset(res1, padj < 0.05 & abs(log2FoldChange) > 1),  # Label only significant genes
    na.rm = T,
    aes(label = common_name),  # Use gene names as labels
    box.padding = 0.5,  # Adjust spacing around labels
    max.overlaps = Inf,  # Allow unlimited overlaps (or set a finite number)
    segment.color = "gray",  # Color of the line connecting the label to the point
    segment.size = 0.5  # Thickness of the connecting line
  )
```

# Volcano Plots for TRPRS2 

```{r volcano_less_clutter}
top_upregulated <- res2 %>%
  filter(padj < 0.05 & log2FoldChange > 1) %>%
  arrange(padj) %>%
  head(10)

top_downregulated <- res2 %>%
  filter(padj < 0.05 & log2FoldChange < -1) %>%
  arrange(padj) %>%
  head(10)


# Combine top upregulated and downregulated genes
top_genes <- bind_rows(top_upregulated, top_downregulated)


#This one needs less labels (trust me).
#Identify top 10 upregulated and top 10 downregulated genes based on p-value

# Volcano plot with only top 10 up and down genes labeled
ggplot(res2, aes(x = log2FoldChange, y = -log10(padj))) +
  geom_point(aes(color = padj < 0.05 & abs(log2FoldChange) > 1), alpha = 0.7, na.rm = T) +
  scale_color_manual(values = c("black", "red")) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(
    title = "Volcano Plot: TRPRS2 vs WT",
    x = "Log2 Fold Change",
    y = "-Log10 Adjusted P-value"
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "blue") +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "blue") +
  geom_text_repel(
    data = top_genes,
    na.rm = T,
    aes(label = common_name),
    box.padding = 0.5,
    max.overlaps = Inf,
    segment.color = "gray",
    segment.size = 0.5
  )
```

# A memory usage test
```{r find_sizes}
sort(sapply(ls(), function(x) object.size(get(x))), decreasing = TRUE)
```

USE THIS BELOW!!!! NOT KNIT BUTTON
To render without GUI, enter this into R console:

rmarkdown::render("/cloud/project/scripts/07_vargas_deseq.Rmd", output_dir = "/cloud/project/results")

